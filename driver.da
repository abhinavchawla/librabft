import sys
from memPool import MemPool
from nacl.signing import SigningKey
from leaderElection import LeaderElection
from blockTree import BlockTree
from pacemaker import Pacemaker
from verificationHelper import sign, verify
import string
import random
import pickle

class Message:	
    pass

class TimeoutInfo(Message):                                                 # TimeoutInfo
    def __init__(self, round, high_qc, sender, signature):  
        self.round = round                                                  #   round;
        self.high_qc = high_qc                                              #   high_qc;
        self.sender = sender                                                #   sender <- u; // Added automatically when constructed
        self.signature = signature                                          #   signature <- sign_u(round,high_qc.round); // Signed automatically when constructed

class TC(Message):                                                          # TC
    def __init__(self, round, tmo_high_qc_rounds, tmo_signatures):
        self.round = round                                                  #   round; // All timeout messages that form TC have the same round
        self.tmo_high_qc_rounds = tmo_high_qc_rounds                        #   tmo_high_qc_rounds; // A vector of 2f+1 high qc round numbers of timeout messages that form TC
        self.tmo_signatures = tmo_signatures                                #   tmo_signatures; // A vector of 2f+1 validator signatures on (round, respective high qc round)

class TimeoutMsg(Message):                                                  # TimeoutMsg
    def __init__(self, tmo_info, last_round_tc, high_commit_qc):
        self.tmo_info = tmo_info                                            #   tmo_info; // TimeoutInfo for some round with a high_qc
        self.last_round_tc = last_round_tc                                  #   last_round_tc; // TC for tmo_info.round-1 if tmo_info.high_qc.round ≠ tmo_info.round-1, else ⊥
        self.high_commit_qc = high_commit_qc                                #   high_commit_qc; // QC to synchronize on committed blocks

class ProposalMsg(Message):				                                    # ProposalMsg 
    def __init__(self, block, last_round_tc, high_commit_qc, signature=None):
        self.block = block			                                        #   block;
        self.last_round_tc = last_round_tc				                    #   last_round_tc; // TC for block.round-1 if block.qc.vote_info.round ≠ block.round-1, else ⊥
        self.high_commit_qc = high_commit_qc					            #   high_commit_qc; // QC to synchronize on committed blocks
        self.signature = signature				                            #   signature <- sign_u(block.id)

class RequestMsg(Message):				                                    # ProposalMsg 
    def __init__(self, txn):
        self.transaction = txn 			                            #   signature <- sign_u(block.id)


class Client(process):
    def setup(c_id,private_key, public_keys, validators):
        self.c_id = c_id
        self.private_key = private_key
        self.public_keys = public_keys
        self.validators =validators

    def run():
        letters = string.ascii_lowercase
        for i in range(1):
            request = sign(self.private_key, ''.join(random.choice(letters) for i in range(10)))
            send(('requestMessage',(request, self.c_id)), to= validators)           #       send vote_msg to LeaderElection.get_leader(current_round+1)

class Validator(process):
    def setup(v_id, private_key, public_keys_validators, public_keys_clients, validators:set):
        self.v_id = v_id
        self.validators = validators
        self.private_key = private_key
        self.public_keys_validators = public_keys_validators
        self.public_keys_clients = public_keys_clients

        self.n = len(validators)
        self.leaderElection = LeaderElection(validators)
        self.blockTree = BlockTree(None, None, None, None, self)
        self.memPool = MemPool()
        self.pacemaker = Pacemaker()

    def process_certificate_qc(qc):                                     # Procedure process_certificate_qc(qc) ### Check for qc being None
        output('Processing certificate qc ', qc)
        if qc:
            blockTree.process_qc(qc)                                        #   BlockTree.process_qc(qc)
            leaderElection.update_leaders(qc)                               #   LeaderElection.update_leaders(qc)
            pacemaker.advance_round(qc.vote_info_round)                     #   Pacemaker.advance_round(qc.vote_info_round)

    def process_proposal_msg(P, sender):                                        # Procedure process_proposal_msg(P)
        output('inside process_proposal_msg ', P)
        process_certificate_qc(P.block.qc)                              #   process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)                        #   process_certificate_qc(P.high_commit_qc)
        pacemaker.advance_round_tc(P.last_round_tc)                     #   Pacemaker.advance_round_tc(P.last_round_tc)
        current_round = pacemaker.current_round                                 #   round <- Pacemaker.current_round
        leader = leaderElection.get_leader(current_round)               #   leader = LeaderElection.get_leader(current_round)

        if P.block.round != current_round or sender != leader or P.block.author != leader:                                #   if P.block.round ≠ round ∨ P.sender ≠ leader ∨ P.block.author ≠ leader then
            return                                                      #       return
        blockTree.execute_and_insert(P)                                 #   Block-Tree.execute_and_insert(P) // Adds a new speculative state to the Ledger
        vote_msg = safety.make_vote(P.block, P.last_round_tc)           #   vote_msg <- Safety.make_vote(P.block, P.last_round_tc)
        if vote_msg is not None:                                        #   if vote_msg ≠ ⊥ then
            next_leader = leaderElection.get_leader(current_round+1)
            send(('voteMessage',(vote_msg)), to= next_leader)           #       send vote_msg to LeaderElection.get_leader(current_round+1)

    def process_timeout_msg(M):                                         # Procedure process_timeout_msg(M)
        process_certificate_qc(M.tmo_info.high_qc)                      #   process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)                        #   process_certificate_qc(M.high_commit_qc)
        pacemaker.advance_round_tc(M.last_round_tc)                     #   Pacemaker.advance_round_tc(M.last_round_tc)
        tc = pacemaker.process_remote_timeout(M)                        #   tc <- Pacemaker.process_remote_timeout(M)
        if tc is not None:                                              #   if tc ≠ ⊥ then
            pacemaker.advance_round(tc)                                 #       Pacemaker.advance_round(tc)
            process_new_round_event(tc)                                 #       process_new_round_event(tc)

    def process_vote_msg(M):                                            # Procedure process_vote_msg(M)
        qc = blockTree.process_vote(M)                                  #   qc <- Block-Tree.process_vote(M)
        if qc is not None:                                              #   if qc ≠ ⊥ then
            process_certificate_qc(qc)                                  #       process_certificate_qc(qc)
            process_new_round_event(None)                               #       process_new_round_event(⊥)

    def process_request_msg(signed_txn, c_id):
        output(signed_txn.message)
        verify(self.public_keys_clients[c_id], signed_txn)
        txn = pickle.loads(signed_txn.message)
        output("Request Received from client", c_id,": ", v_id, txn)

    def process_new_round_event(last_tc):                               # Procedure process_new_round_event(last_tc)
        output('inside process_new_round_event')
        current_round = pacemaker.current_round
        if self == leaderElection.get_leader(current_round):  #   if u = LeaderElection.get_leader(pacemaker.current_round) then
                                                                        #   // Leader code: generate proposal
            b = blockTree.generate_block(memPool.get_transactions(), \
                pacemaker.current_round)                                #       b <- Block-Tree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
            output('message being sent ', b)
            send(('proposalMessage',(ProposalMsg(b,last_tc, blockTree.high_commit_qc))), to=validators) # broadcast ProposalMsg<b,last_tc,Blcok-Tree.high_commit_qc>

    def receive(msg=('localTimeout', m,), from_= p):                    # if M is a local timeout then
        output('in localTimeout receive ', m)
        pacemaker.local_timeout_round()                                 #   Pacemaker.local_timeout_round() ### will have to pass validators while creating pacemaker object

    def receive(msg=('proposalMessage', m,), from_= p):                 # if M is a proposal message then
        output('in proposalMessage receive ', m)
        process_proposal_msg(m, p)                                         #   process_proposal_msg(M)

    def receive(msg=('voteMessage', m,), from_= p):                     # if M is a vote message then
        output('in voteMessage receive ', m)
        process_vote_msg(m)                                             #   process_vote_msg(M)                                                        

    def receive(msg=('timeoutMessage', m,), from_= p):                  # if M is a timeout message then
        output('in timeoutMessage receive ', m)
        process_timeout_message(m)                                      #   process_timeout_message(M)
    
    def receive(msg=('requestMessage', m), from_= p):
        process_request_msg(m[0], m[1])

    def run():
        # signed = sign(lst)
        # verify(public_keys[id], signed)
        if v_id == 0:
            process_new_round_event(None)
        else:
            await(False)



def main():
    nvalidators = int(sys.argv[1]) if len(sys.argv) > 1 else 4
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 3 else 3000

    clients = new(Client, num=nclients)
    validators = new(Validator, num=nvalidators)
    public_keys_validators=[]
    private_keys_validators=[]
    for _ in range(nvalidators):
        sk = SigningKey.generate()
        pk = sk.verify_key
        public_keys_validators.append(pk)
        private_keys_validators.append(sk)
    
    public_keys_clients=[]
    private_keys_clients=[]
    for _ in range(nvalidators):
        sk = SigningKey.generate()
        pk = sk.verify_key
        public_keys_clients.append(pk)
        private_keys_clients.append(sk)
    output(validators)
    for i, v in enumerate(validators):
        setup({v}, (i, private_keys_validators[i], public_keys_validators, public_keys_clients, validators))
    for i, c in enumerate(clients):
        setup({c}, (i, private_keys_clients[i], public_keys_validators, validators))

    start(clients)
    start(validators)

