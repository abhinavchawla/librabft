#type:ignore
import sys
from configs import Failure
from memPool import MemPool
from nacl.signing import SigningKey
from leaderElection import LeaderElection
from blockTree import BlockTree
from pacemaker import Pacemaker
from ledger import Ledger
from safety import Safety
from messages import *
from verificationHelper import sign
import string
import pickle
import threading

import string
import time
import os
import random

from configs import FailType, MsgType

#need to output intial configurations of the test at the start

class Client(process):
    def setup(c_id,private_key, public_keys, validators, n_client_ops, f):
        self.c_id = c_id
        self.private_key = private_key
        self.public_keys = public_keys
        self.validators =validators
        self.f = f
        self.n_client_ops = n_client_ops
        self.xtimer = 10

    def run():
        letters = string.ascii_lowercase
        i = 0
        
        while i<n_client_ops:
            if (i > 2):
                time.sleep(2)
            request = sign(self.private_key, str(self.c_id)+" "+str(i))
            output('sending request message ', i, self.xtimer)
            send(('requestMessage',(request, self.c_id)), to= validators) 
            if await(some(received(('commitMessage', x1, _i)), has=len(setof(p, received(('commitMessage', _x1, _i), from_=p))) >= self.f+1)):
                output("Commit received from f+1", x1)
                i+=1
            elif timeout(self.xtimer):
                output("no commit received for ", i, self.xtimer)
        output('CLIENT IS DONE')
        send(('clientDoneMessage',(request, self.c_id)), to= validators)

    def receive(msg=('commitMessage', m), from_= p):
        output("Received commitMessage", m, " sender:", p , " receiver: ",self.c_id)

class Validator(process):
    def setup(v_id, private_key, public_keys_validators, public_keys_clients, validators, clients, test_case_id, failures=None, file_id=None):
        self.v_id = v_id
        self.validators = validators
        self.private_key = private_key
        self.public_keys_validators = public_keys_validators
        self.public_keys_clients = public_keys_clients
        self.clients = clients
        self.public_key = public_keys_validators[v_id]
        self.n = len(validators)
        self.f = (n-1)/3
        if file_id == None:
            file_id = v_id
        self.ledger = Ledger("Test_"+str(test_case_id)+"_persistent_ledger_"+str(file_id)+".txt")
        self.leaderElection = LeaderElection(validators, self.ledger)
        self.blockTree = BlockTree(self.public_key, self.ledger, self.private_key, v_id)
        self.memPool = MemPool()        
        self.safety = Safety(private_key, public_keys_validators, 0, self.ledger, self.blockTree, v_id)
        self.done = False
        self.clients_done = set()
        self.failures = failures

    ### Pacemaker code
        self.pacemaker_current_round = 1
        self.pacemaker_last_round_tc = None
        self.pacemaker_pending_timeouts = {}
        self.pacemaker_local_timer = 10
        self.pacemaker_timeoutinfo_set = set()

    ## Control variables
        self.done = False
        self.round_done = False

    ## Recovery variables
        self.nonce = 1
        self.status = "Normal"

    ## Syncup variable
        self.msg_map = dict()
        self.mp = dict()

    def pacemaker_stop_timer(current_round):
        self.pacemaker_local_timer = 4000

    def pacemaker_get_round_timer(r):
        delta = 2 
        return 4 * delta

    def pacemaker_start_timer(new_round):
        round_done = True
        self.pacemaker_stop_timer(pacemaker_current_round)
        self.pacemaker_current_round = new_round
        self.pacemaker_local_timer = pacemaker_get_round_timer(self.pacemaker_current_round)

    def pacemaker_local_timeout_round():
        timeout_info = self.safety.make_timeout(self.pacemaker_current_round, self.blockTree.high_qc, self.pacemaker_last_round_tc, self.v_id)
        output("sending timeout message: ",timeout_info," pacemaker last round tc: ",pacemaker_last_round_tc, " high commit qc: ",blockTree.high_commit_qc,level=20)
        send(('timeoutMessage',(TimeoutMsg(timeout_info,pacemaker_last_round_tc, blockTree.high_commit_qc))), to=validators)
        

    def pacemaker_process_remote_timeout(tmo):
        output('processing remote timeout message sender: ', tmo.tmo_info.sender, ' for round: ', tmo.tmo_info.round)
        tmo_info = tmo.tmo_info
        if tmo_info.round < self.pacemaker_current_round:
            return None
        if not any(tmo_info.round == t for t in self.pacemaker_pending_timeouts):
            self.pacemaker_pending_timeouts[tmo_info.round]=[] # ppt[2] = []
        if not any(tmo_info.sender==t.sender  for t in self.pacemaker_pending_timeouts[tmo_info.round]):
            self.pacemaker_pending_timeouts[tmo_info.round].append(tmo_info) # ppt[2] = [B.ti, C.ti]
        if len(self.pacemaker_pending_timeouts[tmo_info.round])==self.f+1:
            pacemaker_stop_timer(self.pacemaker_current_round)
            self.pacemaker_local_timeout_round()  ### wth is bracha timeout
        if len(self.pacemaker_pending_timeouts[tmo_info.round]) == 2*self.f+1: #ppt[2] = [B.ti, C.ti, D.ti]
            return TC(round = tmo_info.round,
                    tmo_high_qc_rounds = [t.high_qc.vote_info.round for t in self.pacemaker_pending_timeouts[tmo_info.round]],
                    tmo_signatures = [t.signature for t in self.pacemaker_pending_timeouts[tmo_info.round]]) ## an array/set of rounds?
        return None
    
    def pacemaker_advance_round_qc(qc):
        if qc and qc.vote_info.round < pacemaker_current_round:
            return False
        pacemaker_last_round_tc = None
        pacemaker_start_timer(qc.vote_info.round+1 if qc else current_round+1) ### Check if round should increase
        return True

    def pacemaker_advance_round_tc(tc):                                 # Function pacemaker_advance_round
        output('in pacemaker_advance_rount_tc')
        if tc == None or tc.round < self.pacemaker_current_round:       #   if tc = ⊥ ∨ tc.round < current round then
            return False                                                #       return false
        pacemaker_last_round_tc = tc                                    #   last round tc ← tc
        pacemaker_start_timer(tc.round+1)                               #   start timer(tc.round + 1)
        return True                                                     #   return true

    def inform_clients():
        txns = self.ledger.get_recent_committed()
        if len(txns)==0:
            output('no transactions found')
            return
        for t in txns:
            if t[0]=='EMPTY':
                continue
            lst = t[0].split(' ')
            client = list(clients)[int(lst[0])]
            output("commit message being sent: ", int(lst[1]), " sender: ",self.v_id, " receiver: ",client,level=20)
            send(('commitMessage', t[1], int(lst[1])), to=client)           #       send vote_msg to LeaderElection.get_leader(current_round+1)

    def process_certificate_qc(qc):                                         # Procedure process_certificate_qc(qc) ### Check for qc being None
        output('in process_certificate_qc')
        if qc:                                                              ## if qc not None // Handling genesis code
            self.blockTree.process_qc(qc)                                   #   BlockTree.process_qc(qc)
            self.inform_clients()
            pacemaker_advance_round_qc(qc)                                  #   Pacemaker.advance_round(qc.vote_info_round)
            self.leaderElection.update_leaders(qc, pacemaker_current_round) #   LeaderElection.update_leaders(qc)

    def get_leader(round):
        return leaderElection.get_leader(round)

    def get_public_key(pid):
        index = validators.index(pid)
        return public_keys_validators[index]

    def process_proposal_msg(P, sender):                                                    # Procedure process_proposal_msg(P)
        ### output('inside process_proposal_msg ', P)
        if P.block.round > pacemaker_current_round + 1: # Please think shivam, we are dying - Multiple proposals coming in, while syncup
            output('seems like the replica is lagging, lets do recovery P.block.round: ', P.block.round, ' pacemaker_current_round ', pacemaker_current_round)
            self.status = "Transitioning"
            intiateRecoveryProcess(pacemaker_current_round, P.block.round-1, sender)
            await (self.status == "Normal")
            output('seems like the replica has completed the recovery P.block.round: ', P.block.round, ' pacemaker_current_round ', pacemaker_current_round)

            return
        ### output('Checkpoint proposal message 2')
        process_certificate_qc(P.block.qc)                                                  #   process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)                                            #   process_certificate_qc(P.high_commit_qc)        
        pacemaker_advance_round_tc(P.last_round_tc)                                         #   Pacemaker.advance_round_tc(P.last_round_tc)       
        current_round = pacemaker_current_round                                             #   round <- Pacemaker.current_round
        leader = get_leader(current_round) 
        # output('leader: ', leader, sender, P.block.author, get_public_key(leader))
                                 #   leader = LeaderElection.get_leader(current_round)
        if P.block.round != current_round or sender != leader or P.block.author != get_public_key(leader):  #   if P.block.round ≠ round ∨ P.sender ≠ leader ∨ P.block.author ≠ leader then
            output ('$$$$$$$$$$$$$$$ dropping the proposal')
            return                                                                          #       return
        # adding message to the self.msg_map for replaying by a slow validator
        self.msg_map[current_round-1] = create_proposal_msg(P, sender)
        # output('msg map added in round: ', current_round-1, ' is: ', self.msg_map)
        ##########################################################################
        blockTree.execute_and_insert(P.block)                                               #   Block-Tree.execute_and_insert(P) // Adds a new speculative state to the Ledger
        ### output('Checkpoint proposal message 3')
        memPool.mark_transaction_pending(P.block.payload)
        vote_msg = safety.make_vote(P.block, P.last_round_tc)                               #   vote_msg <- Safety.make_vote(P.block, P.last_round_tc)
        output('vote_msg: ', vote_msg)
        if vote_msg is not None:                                                            #   if vote_msg ≠ ⊥ then
            next_leader = get_leader(current_round+1)
            output("Sending vote message: ",vote_msg, " sender: ",self.v_id," receiver: ",next_leader,level=20)
            send(('voteMessage',(vote_msg)), to= next_leader)                               # send vote_msg to LeaderElection.get_leader(current_round+1)

    def process_timeout_msg(M):                                                     # Procedure process_timeout_msg(M)
        output (' in process_timeout_msg')
        process_certificate_qc(M.tmo_info.high_qc)                                  # process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)                                    # process_certificate_qc(M.high_commit_qc)
        pacemaker_advance_round_tc(M.last_round_tc)                                 # Pacemaker.advance_round_tc(M.last_round_tc)
        tc = pacemaker_process_remote_timeout(M)                                    # tc <- Pacemaker.process_remote_timeout(M)
        if tc is not None:                                                          # if tc ≠ ⊥ then            
            output('timeout certificate created is ', pickle.dumps(tc))
            self.msg_map[pacemaker_current_round] = create_timeout_msg(M, tc)
            output('timeout message for round :', pacemaker_current_round, ' added to map: ', self.msg_map)
            pacemaker_advance_round_tc(tc)  #  current_round = 3                    # Pacemaker.advance_round(tc)
            process_new_round_event(tc)                                             # process_new_round_event(tc)
            output('############ timeout certificate successfully created for round: ', tc.round, ' system moving to round: ', self.pacemaker_current_round)

    def process_vote_msg(M):                                                        # Procedure process_vote_msg(M)
        qc = blockTree.process_vote(M)                                               # qc <- Block-Tree.process_vote(M)
        if qc is not None:                                                           # if qc ≠ ⊥ then
            output("Quorum formed. QC: ", qc, "leader: ",self,level=20)
            process_certificate_qc(qc)                                               # process_certificate_qc(qc)
            process_new_round_event(None)                                            # process_new_round_event(⊥)

    def process_request_msg(signed_txn, c_id):
        self.public_keys_clients[c_id].verify(signed_txn.message, signed_txn.signature)
        txn = pickle.loads(signed_txn.message)
        self.memPool.add_transactions(txn)

    def process_client_done_msg(p):
        clients_done.add(p)
        if len(clients_done)==len(clients):
            self.done = True
            output("ALL CLIENTS ARE DONE")

    def process_new_round_event(last_tc):                                                                               # Procedure process_new_round_event(last_tc)
        current_round = self.pacemaker_current_round # round = 3
        if self == get_leader(current_round):                                                            # if u = LeaderElection.get_leader(pacemaker.current_round) then
                                                                                                                        # Leader code: generate proposal
            output ('++++++++++++++++++++++++++++ I am the leader')
            b = blockTree.generate_block(memPool.get_transactions(),pacemaker_current_round)                                                 # b <- Block-Tree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
            if pacemaker_current_round==5:
                output('#################################### leader going to sleep for 25secs')
                self.status = "crashed"
                time.sleep(25)
                self.status = "awake"
                output('#################################### leader woke up')
            #output('message being sent ', pickle.dumps(ProposalMsg(b,last_tc, blockTree.high_commit_qc)))
            output("******************************** yay proposal for round: ", self.pacemaker_current_round)
            output("sending proposal message: ", b, " last timeout certificate: ",last_tc , " high commit qc: ", blockTree.high_commit_qc , " sender: ",self.v_id, " receiver: ",self.validators, level=20)
            send(('proposalMessage',(ProposalMsg(b,last_tc, blockTree.high_commit_qc))), to=validators)                 # broadcast ProposalMsg<b,last_tc,Blcok-Tree.high_commit_qc>


    def intiateRecoveryProcess(r1, r2, sender):                                           # Procedure initiateRecoveryProcess:
        output('checkpoint 1 intiateRecoveryProcess called')
        send(('initiateRecovery', self.nonce, r1, r2), to=sender)        #   send initiateRecovery with a nonce id to all other validators

    def process_recovery_msg(n, r1, r2, sender):
        output('checkpoint 1 process_recovery_msg called')
        if (r2 <= self.pacemaker_current_round):
            recMsg = {key:self.msg_map[key] for key in range(r1, r2)}
            output('recovery message being sent is: ', recMsg)
            send(('recoveryMsg', recMsg, hash(pickle.dumps(recMsg)), n), to= sender)

    # if M is a local timeout then
    # Pacemaker.local_timeout_round() ### will have to pass validators while creating pacemaker object
    def receive(msg=('localTimeout', m,), from_= p):
        output('localTimeout message received: ', m ," sender: ",p," receiver: ",self.v_id,level=20)
        pacemaker_local_timeout_round()

    # if M is a proposal message then
    #   process_proposal_msg(M)
    def receive(msg=('proposalMessage', m,), from_= p):
        output('proposal message received: ', m, " sender: ",p," receiver: ",self.v_id, " for round: ", m.block.round, " with validator current round: ", self.pacemaker_current_round, level=20)
        output('current status ', self.status)
        process_proposal_msg(m, p)
    
    def receive(msg=('voteMessage', m,), from_= p):                                             # if M is a vote message then
        output('vote Message received: ', m," sender: ",p, " receiver: ",self.v_id,level=20)
        process_vote_msg(m)                                                                     #   process_vote_msg(M)

    def receive(msg=('timeoutMessage', m,), from_= p):                                          # if M is a timeout message then
        output('timeout Message received: ', m, " sender: ",p," receiver: ",self.v_id, " for round: ", m.tmo_info.round, " with validator current round: ", self.pacemaker_current_round, level=20)
        process_timeout_msg(m)                                                                  #   process_timeout_message(M)
    
    def receive(msg=('requestMessage', m), from_= p):
        output("request message received: ",m, " sender: ",m[1], " receiver: ",self.v_id,level=20)
        process_request_msg(m[0], m[1])
    
    def receive(msg=('clientDoneMessage', m), from_= p):
        output('in clientDoneMessage receive')
        process_client_done_msg(p)

    def receive(msg=('initiateRecovery', n, r1, r2), from_= p):
        output('in initiateRecovery receive ', n)
        if (self != p):
            process_recovery_msg(n, r1, r2, p)

    def receive(msg=('recoveryMsg', m, x, n), from_= p):
        output('in recoveryMsg receive ', x)
        mp.clear()
        # no point waiting for all the messages. As soon as you receive the message, just validate and process
        if some(received(('recoveryMsg', m , x, _nonce))):
            self.nonce = self.nonce+1
            for e in m:
                l1 = dict()
                for i in m[e]:
                    l1[i] = m[e][i]
                mp[e] = l1
            output('mp is: ', mp)

        # Syncup the system
        
        output('starting the sync-up process')
        for key in mp:
            output('processing syncing for round: ', key, ' with pacemaker round: ', pacemaker_current_round)
            if key != pacemaker_current_round:
                output('something wrong with the results') ### decide on next course of action

            if mp[key]['msg_type'] == 'proposal':
                output('syncing proposal for round: ', key)
                process_proposal_msg(mp[key]['message'], mp[key]['sender'])

            if mp[key]['msg_type'] == 'timeout':
                output('syncing timeout for round: ', key)
                process_certificate_qc(mp[key]['high_qc'])                                  # process_certificate_qc(M.tmo_info.high_qc)
                process_certificate_qc(mp[key]['high_commit_qc'])                                    # process_certificate_qc(M.high_commit_qc)
                pacemaker_advance_round_tc(mp[key]['message'])
                output('syncing timeout for round: ', key, ' is done')
        self.status = "Normal"
                
    def create_proposal_msg(P, sender):
        return {"msg_type": "proposal", "message": P, "sender" : sender}

    def create_timeout_msg(M, tc):
        return {"msg_type": "timeout", "message": tc, "high_qc": M.tmo_info.high_qc, "high_commit_qc": M.high_commit_qc}

    def run():
        process_new_round_event(None)
        while not self.done:            
            round_done = False
            timer_duration = pacemaker_get_round_timer(pacemaker_current_round)
            if await(round_done):
                output('round done')
                pass
            elif timeout(timer_duration):
                output('no message received from the leader:', get_leader(pacemaker_current_round), ' timeout reported in the system')
                pacemaker_local_timeout_round()
        send('done', to=parent())              
        exit()

def main():
    config(visualize is True)
    nvalidators = int(sys.argv[1]) if len(sys.argv) > 1 else 4
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 1

    clients = new(Client, num=nclients)
    validators = new(Validator, num=nvalidators)
    public_keys_validators=[]
    private_keys_validators=[]
    for _ in range(nvalidators):
        sk = SigningKey.generate()
        pk = sk.verify_key
        public_keys_validators.append(pk)
        private_keys_validators.append(sk)
    #print(public_keys_validators)
    #print(private_keys_validators)
    public_keys_clients=[]
    private_keys_clients=[]
    for _ in range(nclients):
        sk = SigningKey.generate()
        pk = sk.verify_key
        public_keys_clients.append(pk)
        private_keys_clients.append(sk)
    #output(validators)
    for i, v in enumerate(validators):
        setup({v}, (i, private_keys_validators[i], public_keys_validators, public_keys_clients, list(validators), clients, 10))
    for i, c in enumerate(clients):
        setup({c}, (i, private_keys_clients[i], public_keys_validators, validators, 10, 1))

    start(clients)
    start(validators)

    await (each(v in validators, has= received('done', from_=v)))
    output('done with all the validator work, quitting')



class ValidatorX( process, Validator):
    'Twins Validator'

    def setup(v_id, private_key, public_keys_validators, public_keys_clients, validators:set, clients, test_case_id, failures, playground, leaders, file_id):
        super().setup(v_id, private_key, public_keys_validators, public_keys_clients, validators, clients, test_case_id, failures, file_id)
        self.playground = playground
        self.leaders = leaders

    def send(message, to):
        updated_message = (*message, to)
        output(updated_message)
        super().send(updated_message, to=self.playground)
    
    def generate_random_transaction():
        letters = string.ascii_letters
        return ''.join(random.choice(letters) for i in range(10))

    def process_new_round_event(last_tc):
        current_round = self.pacemaker_current_round # round = 3
        output("current_round: ", current_round)
        if self.v_id == self.leaders[str(current_round)]:                                                            # if u = LeaderElection.get_leader(pacemaker.current_round) then                                                                                                            # Leader code: generate proposal
            b = blockTree.generate_block(generate_random_transaction(),pacemaker_current_round)                                                 # b <- Block-Tree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
            # if pacemaker_current_round==9:
            #     output('leader going to sleep for 25secs')
            #     exit()
            # output('message being sent ', pickle.dumps(ProposalMsg(b,last_tc, blockTree.high_commit_qc)))
            output("yay proposal")
            output("sending proposal message: ", b, " last timeout certificate: ",last_tc , " high commit qc: ", blockTree.high_commit_qc , " sender: ",self.v_id, " receiver: ",self.validators, level=20)
            send(('proposalMessage',(ProposalMsg(b,last_tc, blockTree.high_commit_qc))), to=validators)                 # broadcast ProposalMsg<b,last_tc,Blcok-Tree.high_commit_qc>
    def receive(msg=('proposalMessagePlay', m,sender), from_= p):
        output('proposal message received here: ', m, " sender: ",sender," receiver: ",self.v_id, level=20)
        process_proposal_msg(m, sender)
    
    def receive(msg=('voteMessagePlay', m,sender), from_= p):
        output('Vote message received here: ', m, " sender: ",sender," receiver: ",self.v_id, level=20)
        process_vote_msg(m)

    def receive(msg=('timeoutMessagePlay', m,sender), from_= p):
        output('Timeout message message received here: ', m, " sender: ",sender," receiver: ",self.v_id, level=20)
        process_timeout_msg(m)

    def receive(msg=('initiateRecoveryPlay', n, r1, r2, sender), from_=p):
        output('in initiateRecoveryPlay receive ', n)
        if (self != sender):
            process_recovery_msg(n, r1, r2, sender)

    def receive(msg=('recoveryMsgPlay', m, x, n, sender), from_=p):
        output('in recoveryMsgPlay receive ', x)
        mp.clear()
        # no point waiting for all the messages. As soon as you receive the message, just validate and process
        if some(received(('recoveryMsgPlay', m, x, _nonce, sender))):
            self.nonce = self.nonce + 1
            for e in m:
                l1 = dict()
                for i in m[e]:
                    l1[i] = m[e][i]
                mp[e] = l1
            output('mp is: ', mp)

        # Syncup the system

        output('starting the sync-up process')
        for key in mp:
            output('processing syncing for round: ', key, ' with pacemaker round: ', pacemaker_current_round)
            if key != pacemaker_current_round:
                output('something wrong with the results')  ### decide on next course of action

            if mp[key]['msg_type'] == 'proposal':
                output('syncing proposal for round: ', key)
                process_proposal_msg(mp[key]['message'], mp[key]['sender'])

            if mp[key]['msg_type'] == 'timeout':
                output('syncing timeout for round: ', key)
                process_certificate_qc(mp[key]['high_qc'])  # process_certificate_qc(M.tmo_info.high_qc)
                process_certificate_qc(mp[key]['high_commit_qc'])  # process_certificate_qc(M.high_commit_qc)
                pacemaker_advance_round_tc(mp[key]['message'])
                output('syncing timeout for round: ', key, ' is done')
        self.status = "Normal"

    def get_leader(round):
        return list(validators)[self.leaders[str(round)]]

    def inform_clients():
        pass
    
# Replica with Fault Injection
class ValidatorFI(process, Validator):
    def get_failure_config(message, to):
        output("CHECK HERE 1 - ",message, to)
        if self.failures is None:
            return None
        for failure_config in self.failures:
            # only allow SetAttr fail type to last nfaulty validators
            if failure_config.fail_type == FailType.SetAttr and self.v_id >= len(self.validators) - self.f:
                continue

            if failure_config.round != self.pacemaker_current_round:
                continue
            
            output("checkpoint 1 - ",failure_config, message,to)
            if failure_config.src == "leader":
                if self.leaderElection.get_leader(self.pacemaker_current_round) != list(self.validators)[self.v_id]:
                    continue
            elif failure_config.src != "_" and failure_config.src != self.v_id:
                continue
            
            output("checkpoint 2 - ",failure_config, message, to)
            if failure_config.dest == "leader":
                if failure_config.msg_type == MsgType.Vote and self.leaderElection.get_leader(self.pacemaker_current_round + 1) != to:
                    output("checkpoint 4 - ",failure_config, self.leaderElection.get_leader(self.pacemaker_current_round + 1), to)
                    continue
                if failure_config.msg_type != MsgType.Vote and self.leaderElection.get_leader(self.pacemaker_current_round) != to:
                    continue
            elif failure_config.dest != "_" and list(self.validators)[failure_config.dest] != to:
                continue

            # if random.random() < 1 - failure_config.prob:
            #     continue
            return failure_config
        return None

    def send_msg_delayed(message, to, val):
        output("STARTED SLEEPING")
        time.sleep(val*1000)
        output("WOKE UP")
        super().send(message, to)

    def send(message, to):
        pass

        # failure_config = get_failure_config(message, to)
        # output('ValidatorFI.send', failure_config)
        # if failure_config is None:
        #     output("REACHED FAILURE CONFIG CHECK IS NONE")
        #     super().send(message, to)
        # else:
        #     output('Sending potential faulty msg',
        #                       failure_config.fail_type.name, message, to)
        #     if failure_config.fail_type == FailType.MsgLoss:
        #             output('ValidatorFI.send', 'message dropped')
        #     elif failure_config.fail_type == FailType.Delay:
        #         output('ValidatorFI.send', 'message delayed')
        #         thread = threading.Thread(target=send_msg_delayed, args=(
        #             message, to, failure_config.val))
        #         thread.start()
        #     elif failure_config.fail_type == FailType.SetAttr:
        #         output('ValidatorFI.send', 'config changed')
        #         setattr(failure_config.attr, failure_config.val)
        #     else:
        #         output('error: ValidatorFI.send: unsupported fail type',
        #                failure_config.fail_type)


    