import sys
from nacl.signing import SigningKey
import pickle

class Message:	
    pass

class TimeoutInfo(Message):                                                 # TimeoutInfo
    def __init__(self, round, high_qc, sender, signature):  
        self.round = round                                                  #   round;
        self.high_qc = high_qc                                              #   high_qc;
        self.sender = sender                                                #   sender <- u; // Added automatically when constructed
        self.signature = signature                                          #   signature <- sign_u(round,high_qc.round); // Signed automatically when constructed

class TC(Message):                                                          # TC
    def __init__(self, round, tmo_high_qc_rounds, tmo_signatures):
        self.round = round                                                  #   round; // All timeout messages that form TC have the same round
        self.tmo_high_qc_rounds = tmo_high_qc_rounds                        #   tmo_high_qc_rounds; // A vector of 2f+1 high qc round numbers of timeout messages that form TC
        self.tmo_signatures = tmo_signatures                                #   tmo_signatures; // A vector of 2f+1 validator signatures on (round, respective high qc round)

class TimeoutMsg(Message):                                                  # TimeoutMsg
    def __init__(self, tmo_info, last_round_tc, high_commit_qc):
        self.tmo_info = tmo_info                                            #   tmo_info; // TimeoutInfo for some round with a high_qc
        self.last_round_tc = last_round_tc                                  #   last_round_tc; // TC for tmo_info.round-1 if tmo_info.high_qc.round ≠ tmo_info.round-1, else ⊥
        self.high_commit_qc = high_commit_qc                                #   high_commit_qc; // QC to synchronize on committed blocks

class ProposalMsg(Message):				                                    # ProposalMsg 
    def __init__(self, block, last_round_tc, high_commit_qc, signature):
        self.block = block			                                        #   block;
        self.last_round_tc = last_round_tc				                    #   last_round_tc; // TC for block.round-1 if block.qc.vote_info.round ≠ block.round-1, else ⊥
        self.high_commit_qc = high_commit_qc					            #   high_commit_qc; // QC to synchronize on committed blocks
        self.signature = signature				                            #   signature <- sign_u(block.id)

class Client(process):
    pass

class Validator(process):
    def setup(id,private_key,public_keys, validators:set):
        self.id = id
        self.validators = validators
        self.private_key = private_key
        self.public_keys = public_keys
        
    def sign(message):
        bytes = pickle.dumps(message)  # Convert any object to bytes
        return private_key.sign(message)
    
    def verify(message, id):
        try:
            public_keys[id].verify(message)
        except:
            output("Unable to verify signature")

    def process_certificate_qc(qc):                                     # Procedure process_certificate_qc(qc) ### Check for qc being None
        blockTree.process_qc(qc)                                        #   BlockTree.process_qc(qc)
        leaderElection.update_leaders(qc)                               #   LeaderElection.update_leaders(qc)
        pacemaker.advance_round(qc.vote_info_round)                     #   Pacemaker.advance_round(qc.vote_info_round)

    def process_proposal_msg(P):                                        # Procedure process_proposal_msg(P)
        process_certificate_qc(P.block.qc)                              #   process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)                        #   process_certificate_qc(P.high_commit_qc)
        pacemaker.advance_round_tc(P.last_round_tc)                     #   Pacemaker.advance_round_tc(P.last_round_tc)
        round = pacemaker.current_round                                 #   round <- Pacemaker.current_round
        leader = leaderElection.get_leader(current_round)               #   leader = LeaderElection.get_leader(current_round)
        if P.block.round != round or P.sender != leader \
            or P.block.author != leader:                                #   if P.block.round ≠ round ∨ P.sender ≠ leader ∨ P.block.author ≠ leader then
            return                                                      #       return
        blockTree.execute_and_insert(P)                                 #   Block-Tree.execute_and_insert(P) // Adds a new speculative state to the Ledger
        vote_msg = safety.make_vote(P.block, P.last_round_tc)           #   vote_msg <- Safety.make_vote(P.block, P.last_round_tc)
        if vote_msg is not None:                                        #   if vote_msg ≠ ⊥ then
            next_leader = leaderElection.get_leader(current_round+1)
            send(('voteMessage',(vote_msg)), to= next_leader)           #       send vote_msg to LeaderElection.get_leader(current_round+1)

    def process_timeout_msg(M):                                         # Procedure process_timeout_msg(M)
        process_certificate_qc(M.tmo_info.high_qc)                      #   process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)                        #   process_certificate_qc(M.high_commit_qc)
        pacemaker.advance_round_tc(M.last_round_tc)                     #   Pacemaker.advance_round_tc(M.last_round_tc)
        tc = pacemaker.process_remote_timeout(M)                        #   tc <- Pacemaker.process_remote_timeout(M)
        if tc is not None:                                              #   if tc ≠ ⊥ then
            pacemaker.advance_round(tc)                                 #       Pacemaker.advance_round(tc)
            process_new_round_event(tc)                                 #       process_new_round_event(tc)

    def process_vote_msg(M):                                            # Procedure process_vote_msg(M)
        qc = blockTree.process_vote(M)                                  #   qc <- Block-Tree.process_vote(M)
        if qc is not None:                                              #   if qc ≠ ⊥ then
            process_certificate_qc(qc)                                  #       process_certificate_qc(qc)
            process_new_round_event(None)                               #       process_new_round_event(⊥)

    def process_new_round_event(last_tc):                               # Procedure process_new_round_event(last_tc)
        if self == leaderElection.get_leader(pacemaker.current_round):  #   if u = LeaderElection.get_leader(pacemaker.current_round) then
                                                                        #   // Leader code: generate proposal
            b = blockTree.generate_block(memPool.get_transactions(), \
                pacemaker.current_round)                                #       b <- Block-Tree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
            send(('proposalMessage',(b,last_tc, blockTree.high_commit_qc)), to= validators) # broadcast ProposalMsg<b,last_tc,Blcok-Tree.high_commit_qc>

    def receive(msg=('localTimeout', m,), from_= p):                    # if M is a local timeout then 
        pacemaker.local_timeout_round()                                 #   Pacemaker.local_timeout_round() ### will have to pass validators while creating pacemaker object

    def receive(msg=('proposalMessage', m,), from_= p):                 # if M is a proposal message then
        process_proposal_msg(m)                                         #   process_proposal_msg(M)

    def receive(msg=('voteMessage', m,), from_= p):                     # if M is a vote message then 
        process_vote_msg(m)                                             #   process_vote_msg(M)                                                        

    def receive(msg=('timeoutMessage', m,), from_= p):                  # if M is a timeout message then
        process_timeout_message(m)                                      #   process_timeout_message(M)
    
    def run():
        signed = sign(lst)
        verify(signed, id)

def main():
    nvalidators = int(sys.argv[1]) if len(sys.argv) > 1 else 5
    nclients = int(sys.argv[2]) if len(sys.argv) > 2 else 3
    maxtimeout = int(sys.argv[4]) if len(sys.argv) > 3 else 3000

    clients = new(Client, num=nclients)
    validators = new(Validator, num=nvalidators)
    public_keys=[]
    private_keys=[]
    for _ in range(nvalidators):
        sk = SigningKey.generate()
        pk = sk.verify_key
        public_keys.append(pk)
        private_keys.append(sk)

    for i, v in enumerate(validators):
        setup({v}, (i, private_keys[i], public_keys))
    
    for v in validators:
        start(v)

