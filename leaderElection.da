import math
import random
import pdb

class LeaderElection():
    def __init__(self, validators, ledger):
        self.validators = validators            # validators; // The list of current validators
        self.window_size = 1                    # window_size; // A parameter for the leader reputation algorithm
        self.exclude_size = 2                   # exclude_size; // Between f and 2f, number of excluded authors of last committed blocks
        self.reputation_leaders = {}            # reputation_leaders; // Map from round numbers to leaders elected due to the reputaton scheme
        self.ledger = ledger

    def elect_reputation_leader(self,qc):                                                   # Function elect_reputation_leader(qc)
        active_validators = []                                                              #   active_validators <- ∅ // validators that signed the last window_size committed blocks
        last_authors = []                                                                   #   last_authors <- ∅ // ordered set of authors of last exclude_size committed blocks
        current_qc = qc                                                                     #   current_qc <- qc

        for i in range (0, self.window_size):                                               # for i = 0; i < window_size ∨ |last_authors| < exclude_size; i <- i+1 do
            if len(last_authors) >= self.exclude_size:
                break
            current_block = self.ledger.committed_block(current_qc.vote_info.parent_id)      # current_block <- Ledger.committed_block(current_qc.vote_info.parent_id)
            if current_block!=None:
                block_author = current_block.author                                          # block_author <- current_block.author
                if len(last_authors) <= self.exclude_size:  # if |last_authors| < exclude_size then
                    last_authors = last_authors + [block_author]  # last_authors <- last_authors ∪ {block_author}
            active_validators = active_validators + current_qc.signers                       # active_validators <- active_validators ∪ current_qc.signatures.signer()                                                                          #       // |current_qc.signatures.signer()| >= 2f+1
            if current_block:
                current_qc = current_block.qc                                                #   current_qc <- current_block.qc
        process_id_to_active_validators={}
        for idx in active_validators:
            process_id_to_active_validators[list(self.validators)[idx]]=idx
        for pid in last_authors:
            if pid in process_id_to_active_validators.keys():
                active_validators.remove(process_id_to_active_validators[pid])
        random.seed(qc.vote_info.round)
        return random.choice(active_validators)                                                 # return active_validators.pick_one(seed <- qc.voteinfo.round)

    def update_leaders(self,qc,current_round):                                                          # Procedure update_leaders(qc)
        extended_round = qc.vote_info.parent_round                                                      #   extended_round <- qc.vote_info.parent_round
        qc_round = qc.vote_info.round                                                                   #   qc_round <- qc.vote_info.round
        if extended_round+1 == qc_round and qc_round+1 == current_round:                                #   if extended_round + 1 = qc_round ^ qc_round + 1 = current_round then
            self.reputation_leaders[current_round+1]=self.elect_reputation_leader(qc)                   #       reputation_leaders[current_round + 1] <- elect_reputation_leader(qc)

    def get_leader(self, round):                                                                        # Function get_leader(round)
        if round in self.reputation_leaders.keys():                                                     #   if <round,leader> ∈ reputation_leaders then
            return list(self.validators)[self.reputation_leaders[round]]                                #       return leader // Reputation-based leader
        return list(self.validators)[math.floor(round/2) % len(self.validators)]                        #return list(self.validators)[0]
