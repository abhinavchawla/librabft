import math

class LeaderElection():
    def __init__(self, validators):
        self.validators = validators            # validators; // The list of current validators
        self.window_size = None                 # window_size; // A parameter for the leader reputation algorithm
        self.exclude_size = None                # exclude_size; // Between f and 2f, number of excluded authors of last committed blocks
        self.reputation_leaders = None          # reputation_leaders; // Map from round numbers to leaders elected due to the reputaton scheme

    def elect_reputation_leader(self,qc):            # Function elect_reputation_leader(qc)
        active_validators = None                #   active_validators <- ∅ // validators that signed the last window_size committed blocks
        last_authors = None                     #   last_authors <- ∅ // ordered set of authors of last exclude_size committed blocks
        current_qc = qc                         #   current_qc <- qc

        for i in range (0, window_size):                                                # for i = 0; i < window_size ∨ |last_authors| < exclude_size; i <- i+1 do
            if i >= window_size or len(last_authors) >= exclude_size:
                break
            print(i)
            current_block = Ledger.committed_block(current_qc.vote_info.parent_id)      #   current_block <- Ledger.committed_block(current_qc.vote_info.parent_id)
            block_author = current_block.author                                         #   block_author <- current_block.author
            if i < window_size:                                                         #   if i < window_size then
                active_validators = active_validators | current_qc.signatures.signer()  #       active_validators <- active_validators ∪ current_qc.signatures.signer()
                                                                                        #       // |current_qc.signatures.signer()| >= 2f+1
            if len(last_authors) < exclude_size:                                        #   if |last_authors| < exclude_size then
                last_authors = last_authors | block_author                              #       last_authors <- last_authors ∪ {block_author}
            current_qc = current_block.qc                                               #   current_qc <- current_block.qc
        active_validators = active_validators.difference(last_authors)                  # active_validators <- active_validators \ last_authors // contains at least 1 validator
        return active_validators.pick_one(seed = qc.voteinfo.round)                     # return active_validators.pick_one(seed <- qc.voteinfo.round)                    

    def update_leaders(self,qc):                                                          # Procedure update_leaders(qc)
        extended_round = qc.vote_info.parent_round                                      #   extended_round <- qc.vote_info.parent_round
        qc_round = qc.vote_info.round                                                   #   qc_round <- qc.vote_info.round
        current_round = PaceMaker.current_round                                         #   current_round <- PaceMaker.current_round
        if extended_round+1 == qc_round and qc_round+1 == current_round:                #   if extended_round + 1 = qc_round ^ qc_round + 1 = current_round then
            reputation_leaders[current_round+1] = elect_reputation_leader(qc)           #       reputation_leaders[current_round + 1] <- elect_reputation_leader(qc)

    ### uncomment
    def get_leader(self, round):                                                              # Function get_leader(round)
        # if (round, leader) in reputation_leaders:                                       #   if <round,leader> ∈ reputation_leaders then
        #     return leader                                                               #       return leader // Reputation-based leader
        # return validators[math.floor(round/2) % len(validators)]                        #   return validators[⌊round/2⌋ mod |validtors|] // Round-robin leader (two rounds per leader)
        return list(self.validators)[0]
