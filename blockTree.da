import pickle
from verificationHelper import *

class VoteInfo():                                                                       # VoteInfo
    def __init__(self, id, round, parent_id, parent_round, exec_state_id):  
        self.id = id                                                                    #   id, round; // Id and round of block
        self.round = round
        self.parent_id = parent_id                                                      #   parent_id, parent_round; // Id and round of parent
        self.parent_round = parent_round            
        self.exec_state_id = exec_state_id                                              #   exec_state_id; // Speculated execution state

class LedgerCommitInfo():                                                               # LedgerCommitInfo
    def __init__(self, commit_state_id, vote_info_hash):                                
        self.commit_state_id = commit_state_id                                          #   commit_state_id; // ⊥ if no commite happens when this vote is aggregated to QC
        self.vote_info_hash = vote_info_hash                                            #   vote_info_hash; // Hash of VoteMsg.vote_info

class VoteMsg():                                                                        # VoteMsg
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc, u, signature):                  
        self.vote_info = vote_info                                                      #   vote_info; // A VoteInfo record
        self.ledger_commit_info = ledger_commit_info                                    #   ledger_commit_info; // Speculated ledger info
        self.high_commit_qc = high_commit_qc                                            #   high_commit_qc; // QC to synchronize on committed blocks
        self.sender = u                                                                 #   sender <- u; // Added automatically when constructed
        self.signature = signature                                                      #   signature <- sign_u(ledger_commit_info); // Signed automatically when constructed

# QC is VoteMsg with multiple signatures
class QC():                                                                             # QC
    def __init__(self, vote_info, ledger_commit_info, signatures, author, author_signature, signers):
        self.vote_info = vote_info                                                      #   vote_info;
        self.ledger_commit_info = ledger_commit_info                                    #   ledger_commit_info;
        self.signatures = signatures                                                    #   signatures; // A quorum of signatures
        self.author = author                                                                 #   author <- u; // The validator that produced the qc
        self.author_signature = author_signature                                        #   author_signature <- sign_u(signatures);
        self.signers = signers

class Block():                                                                          # Block
    def __init__(self, author, round, payload, qc, id):
        self.author = author                                                            #   author; // The author of the block, may not be the same as qc.author after view-change
        self.round = round                                                              #   round; // The round that generated this proposal
        self.payload = payload                                                          #   payload; // Proposed transaction(s)
        self.qc = qc                                                                    #   qc; // QC for parent block
        self.id = id                                                                    #   id; // A unique digest of author, round, payload, qc.vote_info.id and qc.signatures

class BlockTree():                                                                     # Block-Tree()
    def __init__(self, author, ledger, private_key, v_id):
        self.pending_block_tree = {}                                                     #   pending_block_tree; // tree of blocks pending commitment
        self.pending_votes = {}                                                          #   pending_votes; // collected votes per block indexed by their LedgerInfo hash
        self.high_qc = None                                                              #   high_qc; // highest known QC
        self.high_commit_qc = None                                                       #   high_commit_qc; // highest QC that serves as a commit certificate
        self.author = author
        self.ledger = ledger
        self.private_key = private_key
        self.v_id = v_id
        self.signers={}

    def __max_round(self, qcA, qcB):
        if not qcA:
            return qcB
        if not qcB:
            return qcA
        return qcA if qcA.vote_info.round > qcB.vote_info.round else qcB

    def pending_block_tree_append(self, b_id,b):
        self.pending_block_tree[b_id] = b
    
    def pending_block_tree_prune(self, b_id):
        self.pending_block_tree.pop(b_id, None)

    def process_qc(self, qc):                                                                                           #Procedure process_qc(qc)
        if qc and qc.ledger_commit_info.commit_state_id is not None:                                                    #       if qc.ledger_commit_info.commit_state_id ≠ ⊥ then
            self.ledger.commit(qc.vote_info.parent_id)                                                                  #        Ledger.commit(qc.vote_info.parent_id)
            self.pending_block_tree_prune(qc.vote_info.parent_id)                                                     #           pending_block_tree.prune(qc.vote_info.parent_id) // parent id becomes the new root of pending
            self.high_commit_qc = self.__max_round(qc, self.high_commit_qc)                                             #           high_commit_qc <- max_round{qc, high_commit_qc}
        self.high_qc = self.__max_round(qc, self.high_qc)                                                               #           high_qc <- max_round{qc, high_qc}

    def execute_and_insert(self, b):                                                                                    #   Procedure execute_and_insert(b)
        prev_block_id = None
        if b.qc:
            prev_block_id = b.qc.vote_info.id
        self.ledger.speculate(prev_block_id, b.id, b.payload, b)                                                        #  Ledger.speculate(b.qc.block_id, b.id, b.payload)
        self.pending_block_tree_append(b.id, b)

    def process_vote(self, v):                                                                                          #Function process_vote(v)
        self.process_qc(v.high_commit_qc)                                                                               #       process_qc(v.high_commit_qc)
        vote_idx = hash(pickle.dumps(v.ledger_commit_info))                                                             #       vote_idx <- hash(v.ledger_commit_info)
        if vote_idx not in self.pending_votes.keys():
            self.pending_votes[vote_idx] = []
            self.signers[vote_idx] = []
        self.pending_votes[vote_idx].append(v.signature)                                                                #       pending_votes[vote_idx] <- pending_votes[vote_idx] ∪ v.signature
        self.signers[vote_idx].append(v.sender)
        if len(self.pending_votes[vote_idx]) == 2*1+1:                                                                  #       if |pending_votes[vote_idx]| = 2f+1 then
            qc = QC(                                                                                                    #           qc <- QC<
                    vote_info=v.vote_info,                                                                              #                   vote_info<-v.vote_info,
                    ledger_commit_info=v.ledger_commit_info,
                    author = self.v_id,                                                                                 #                   state_id<-v.state_id,
                    signers = self.signers[vote_idx],                                                                   #                   votes<-pending_votes[vote_idx]>
                    signatures=self.pending_votes[vote_idx],
                    author_signature=sign(self.private_key, self.pending_votes[vote_idx]).signature)
            return qc                                                                                                   #           return qc
        return None                                                                                                     #       return ⊥

    def generate_block(self, txns, current_round):                                                                                                                                              #   Function generate_block(txns, current_round)
        return Block(                                                                                                                                                                           #       return Block<
            author = self.author,                                                                                                                                                               #           author <- u,
            round = current_round,                                                                                                                                                              #           round <- current_round,
            payload = txns,                                                                                                                                                                     #           payload <- txns,
            qc = self.high_qc,                                                                                                                                                                  #           qc <- high_qc,
            id = hash(pickle.dumps((self.author, current_round, txns, self.high_qc.vote_info.id if self.high_qc else None, self.high_qc.signatures if self.high_qc else None))))                #           id <- hash(author || round || payload || qc.vote_info.id || qc.signature)