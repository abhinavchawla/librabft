import pickle
from verificationHelper import *

class VoteInfo():                                                                       # VoteInfo
    def __init__(self, id, round, parent_id, parent_round, exec_state_id):  
        self.id = id                                                                    #   id, round; // Id and round of block
        self.round = round
        self.parent_id = parent_id                                                      #   parent_id, parent_round; // Id and round of parent
        self.parent_round = parent_round            
        self.exec_state_id = exec_state_id                                              #   exec_state_id; // Speculated execution state

class LedgerCommitInfo():                                                               # LedgerCommitInfo
    def __init__(self, commit_state_id, vote_info_hash):                                
        self.commit_state_id = commit_state_id                                          #   commit_state_id; // ⊥ if no commite happens when this vote is aggregated to QC
        self.vote_info_hash = vote_info_hash                                            #   vote_info_hash; // Hash of VoteMsg.vote_info

class VoteMsg():                                                                        # VoteMsg
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc, u, signature):                  
        self.vote_info = vote_info                                                      #   vote_info; // A VoteInfo record
        self.ledger_commit_info = ledger_commit_info                                    #   ledger_commit_info; // Speculated ledger info
        self.high_commit_qc = high_commit_qc                                            #   high_commit_qc; // QC to synchronize on committed blocks
        self.sender = u                                                                 #   sender <- u; // Added automatically when constructed
        self.signature = signature                                                      #   signature <- sign_u(ledger_commit_info); // Signed automatically when constructed

# QC is VoteMsg with multiple signatures
class QC():                                                                             # QC
    def __init__(self, vote_info, ledger_commit_info, signatures, author, author_signature, signers):
        self.vote_info = vote_info                                                      #   vote_info;
        self.ledger_commit_info = ledger_commit_info                                    #   ledger_commit_info;
        self.signatures = signatures                                                    #   signatures; // A quorum of signatures
        self.author = author                                                                 #   author <- u; // The validator that produced the qc
        self.author_signature = author_signature                                        #   author_signature <- sign_u(signatures);
        self.signers = signers

class Block():                                                                          # Block
    def __init__(self, author, round, payload, qc, id):
        self.author = author                                                            #   author; // The author of the block, may not be the same as qc.author after view-change
        self.round = round                                                              #   round; // The round that generated this proposal
        self.payload = payload                                                          #   payload; // Proposed transaction(s)
        self.qc = qc                                                                    #   qc; // QC for parent block
        self.id = id                                                                    #   id; // A unique digest of author, round, payload, qc.vote_info.id and qc.signatures

class BlockTree():                                                                     # Block-Tree()
    def __init__(self, author, ledger, private_key, v_id):
        self.pending_block_tree = []                                                     #   pending_block_tree; // tree of blocks pending commitment
        self.pending_votes = {}                                                          #   pending_votes; // collected votes per block indexed by their LedgerInfo hash
        self.high_qc = None                                                              #   high_qc; // highest known QC
        self.high_commit_qc = None                                                       #   high_commit_qc; // highest QC that serves as a commit certificate
        self.author = author
        self.ledger = ledger
        self.private_key = private_key
        self.v_id = v_id
        self.signers={}

    def __max_round(self, qcA, qcB):
        if not qcA:
            return qcB
        if not qcB:
            return qcA
        return qcA if qcA.vote_info.round > qcB.vote_info.round else qcB
    #process_qc
    #   Procedure process_qc(qc)
    #       if qc.ledger_commit_info.commit_state_id ≠ ⊥ then
    #           Ledger.commit(qc.vote_info.parent_id)
    #           pending_block_tree.prune(qc.vote_info.parent_id) // parent id becomes the new root of pending
    #           high_commit_qc <- max_round{qc, high_commit_qc}
    #       high_qc <- max_round{qc, high_qc}
    def process_qc(self, qc):
        # print("checkpoint 1 BT.Process_qc ", qc)
        if qc and qc.ledger_commit_info.commit_state_id is not None:
            #print("^^^^^^^^^^^^QC.round while committing",qc.vote_info.round+1)
            self.ledger.commit(qc.vote_info.parent_id)
            # self.pending_block_tree.prune(qc.vote_info.parent_id)
            ### check this
            self.high_commit_qc = self.__max_round(qc, self.high_commit_qc)
        self.high_qc = self.__max_round(qc, self.high_qc)
        # print("checkpoint 2 BT.Process_qc ", self.high_qc)
        

    #excute_and_insert
    #   Procedure execute_and_insert(b)
    #       Ledger.speculate(b.qc.block_id, b.id, b.payload)
    #       pending_block_tree.add(b)
    def execute_and_insert(self, b):
        # print('checkpoint 1 execute_and_insert')
        prev_block_id = None
        if b.qc:
            prev_block_id = b.qc.vote_info.id
        self.ledger.speculate(prev_block_id, b.id, b.payload, b)
        # print('checkpoint 2 execute_and_insert Speculate done')
        output("adding to pending block tree: ",b,level=50)
        self.pending_block_tree.append(b)
        # print('checkpoint 3 execute_and_insert pending_block_tree', self.pending_block_tree)

    #process_vote
    #   Function process_vote(v)
    #       process_qc(v.high_commit_qc)
    #       vote_idx <- hash(v.ledger_commit_info)
    #       pending_votes[vote_idx] <- pending_votes[vote_idx] ∪ v.signature
    #       if |pending_votes[vote_idx]| = 2f+1 then
    #           qc <- QC<
    #                   vote_info<-v.vote_info,
    #                   state_id<-v.state_id,
    #                   votes<-pending_votes[vote_idx]>
    #           return qc
    #       return ⊥
    def process_vote(self, v):
        # print ('checkpoint 1 bt.process_vote ', pickle.dumps(v.ledger_commit_info))
        self.process_qc(v.high_commit_qc)
        vote_idx = hash(pickle.dumps(v.ledger_commit_info))
        # print('checkpoint 2 bt.processVote, vote_idx', vote_idx)
        if vote_idx not in self.pending_votes.keys():
            self.pending_votes[vote_idx] = []
            self.signers[vote_idx] = []
        self.pending_votes[vote_idx].append(v.signature)
        self.signers[vote_idx].append(v.sender)
        # print('checkpoint 3 bt.processVote, vote_idx', (self.signers[vote_idx]))
        ### substitute by f value
        if len(self.pending_votes[vote_idx]) == 2*1+1:
            # print('checkpoint 4 bt.process_vote',v)
            qc = QC(
                    vote_info=v.vote_info,
                    ledger_commit_info=v.ledger_commit_info,
                    author = self.v_id,
                    signers = self.signers[vote_idx],
                    signatures=self.pending_votes[vote_idx],
                    author_signature=sign(self.private_key, self.pending_votes[vote_idx]).signature)
            # print("Process_vote completed by forming this QC", qc)
            return qc
        return None

    #generate_block
    #   Function generate_block(txns, current_round)
    #       return Block<
    #           author <- u,
    #           round <- current_round,
    #           payload <- txns,
    #           qc <- high_qc,
    #           id <- hash(author || round || payload || qc.vote_info.id || qc.signature)
    def generate_block(self, txns, current_round):
        # print('inside blockTree.generate_block')
        return Block(
            author = self.author,
            round = current_round,
            payload = txns,
            qc = self.high_qc,
            ### check here
            id = hash(pickle.dumps((self.author, current_round, txns, self.high_qc.vote_info.id if self.high_qc else None, self.high_qc.signatures if self.high_qc else None))))