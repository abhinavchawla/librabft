#type: ignore
class VoteInfo():                                                                       # VoteInfo
    def __init__(self, id, round, parent_id, parent_round, exec_state_id):  
        self.id = id                                                                    #   id, round; // Id and round of block
        self.round = round
        self.parent_id = parent_id                                                      #   parent_id, parent_round; // Id and round of parent
        self.parent_round = parent_round            
        self.exec_state_id = exec_state_id                                              #   exec_state_id; // Speculated execution state

class LedgerCommitInfo():                                                               # LedgerCommitInfo
    def __init__(self, commit_state_id, vote_info_hash):                                
        self.commit_state_id = commit_state_id                                          #   commit_state_id; // ⊥ if no commite happens when this vote is aggregated to QC
        self.vote_info_hash = vote_info_hash                                            #   vote_info_hash; // Hash of VoteMsg.vote_info

class VoteMsg():                                                                        # VoteMsg
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc):                  
        self.vote_info = vote_info                                                      #   vote_info; // A VoteInfo record
        self.ledger_commit_info = ledger_commit_info                                    #   ledger_commit_info; // Speculated ledger info
        self.high_commit_qc = high_commit_qc                                            #   high_commit_qc; // QC to synchronize on committed blocks
        self.sender = u                                                                 #   sender <- u; // Added automatically when constructed
        self.signature = signU(ledger_commit_info)                                      #   signature <- sign_u(ledger_commit_info); // Signed automatically when constructed

# QC is VoteMsg with multiple signatures
class QC():                                                                             # QC
    def __init__(self, vote_info, ledger_commit_info, signatures):
        self.vote_info = vote_info                                                      #   vote_info;
        self.ledger_commit_info = ledger_commit_info                                    #   ledger_commit_info;
        self.signatures = signatures                                                    #   signatures; // A quorum of signatures
        self.author = u                                                                 #   author <- u; // The validator that produced the qc
        self.author_signature = sign_u(signatures)                                      #   author_signature <- sign_u(signatures);

class Block():                                                                          # Block
    def __init__(self, author, round, payload, qc, id):
        self.author = author                                                            #   author; // The author of the block, may not be the same as qc.author after view-change
        self.round = round                                                              #   round; // The round that generated this proposal
        self.payload = payload                                                          #   payload; // Proposed transaction(s)
        self.qc = qc                                                                    #   qc; // QC for parent block
        self.id = id                                                                    #   id; // A unique digest of author, round, payload, qc.vote_info.id and qc.signatures

class Block_Tree():                                                                     # Block-Tree()
    def __init__(self, pending_block_tree, pending_votes, high_qc, high_commit_qc):
        self.pending_block_tree = pending_block_tree                                    #   pending_block_tree; // tree of blocks pending commitment
        self.pending_votes = pending_votes                                              #   pending_votes; // collected votes per block indexed by their LedgerInfo hash
        self.high_qc = high_qc                                                          #   high_qc; // highest known QC
        self.high_commit_qc = high_commit_qc                                            #   high_commit_qc; // highest QC that serves as a commit certificate

    def process_qc(qc):                                                                 #   Procedure process_qc(qc)
        if qc.ledger_commit_info.commit_state_id is not None:                           #       if qc.ledger_commit_info.commit_state_id ≠ ⊥ then
            Ledger.commit(qc.vote_info.parent_id)                                       #           Ledger.commit(qc.vote_info.parent_id)
            pending_block_tree.prune(qc.vote_info.parent_id)                            #           pending_block_tree.prune(qc.vote_info.parent_id) // parent id becomes the new root of pending
            high_commit_qc = max{qc, high_commit_qc}                                    #           high_commit_qc <- max_round{qc, high_commit_qc}
        high_qc = max{qc, high_qc}                                                      #       high_qc <- max_round{qc, high_qc}

    def execute_and_insert(b):                                                          #   Procedure execute_and_insert(b)
        Ledger.speculate(b.qc.block_id, b.id, b.payload)                                #       Ledger.speculate(b.qc.block_id, b.id, b.payload)
        pending_block_tree.add(b)                                                       #       pending_block_tree.add(b)

    def process_vote(v):                                                                #   Function process_vote(v)
        process_qc(v.high_commit_qc)                                                    #       process_qc(v.high_commit_qc)
        vote_idx = hash(v.ledger_commit_info)                                           #       vote_idx <- hash(v.ledger_commit_info)
        pending_votes[vote_idx] = pending_votes[vote_idx] | v.signature                 #       pending_votes[vote_idx] <- pending_votes[vote_idx] ∪ v.signature
        if len(pending_votes[vote_idx]) == 2*f+1:                                       #       if |pending_votes[vote_idx]| = 2f+1 then
            qc = QC(                                                                    #           qc <- QC<
                    vote_info=v.vote_info,                                              #                   vote_info<-v.vote_info,
                    state_id=v.state_id,                                                #                   state_id<-v.state_id,
                    votes=pending_votes[vote_idx])                                      #                   votes<-pending_votes[vote_idx]>
            return qc                                                                   #           return qc
        return None                                                                     #       return ⊥

    def generate_block(txns, current_round):                                            #   Function generate_block(txns, current_round)
        return Block(                                                                   #       return Block<
            author = u,                                                                 #           author <- u,
            round = current_round,                                                      #           round <- current_round,
            payload = txns,                                                             #           payload <- txns,
            qc = high_qc,                                                               #           qc <- high_qc,
            id = hash(author || round || payload || qc.vote_info.id || qc.signature))   #           id <- hash(author || round || payload || qc.vote_info.id || qc.signature)