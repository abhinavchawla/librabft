class Network_Playground(process):
    def setup(num_nodes, num_target_nodes, num_rounds, round_partitions:dict, validators:list):
        self.drop_config_round = {}
        self.speculative_round = 0                  # Current round of the system, based on message intercepted
        self.twin_config = {}
        self.vote_count_config = None
        self.done = False
        self.liveness_timeout = 7 * 10              # (7 * delta), configurable, hopes to receive a proposal or vote message

    def run():
        populate_twin_config()
        populate_drop_config_round()
        print("Validators", validators)
        print("Twin Config", twin_config)
        print("Drop Config", drop_config_round)
        for i, v in enumerate(validators):
            print(f'{v}: {i}')

        while not done:                             # Stopping condition
            round_done = False
            if await (speculative_round >= num_rounds+3):   # Over-guesstimating, when the round becomes num_rounds+3
                done = True                         # stop processing
            elif round_done:
                print ('round done')
            elif timeout(liveness_timeout):
                print ('Liveness Violated')
                done = True

        send (('done', vote_count_config), to=parent())                  # Send a message to parent, ie Executor to let it know of the processing stoppage

    '''
    A node checks the sender of a message based on the public key present in the message.
    When a node replies to a message, it sends a reply to the corresponding node of a public key.
    A node thus maintains a map of (publicKey, nodeId)
    The network playground would then check if the given node (identified by the nodeId), is present
    in the twin_config (ie, is a node with a twin). If the node has a twin, the message gets sent
    to the corresponding twin if the twin is present in the same partitions, or the node if it is present
    in the same partition as the sender, or to both the node and its twin, if all of the three are 
    present in the same partition.
    '''
    def receive(msg=('proposalMessage', m, to), from_= p): # eg received(('proposalMessageSent', (proposalMessage, msg, sender), to), from_=vX)
        round_done = True
        p_msg = m
        block = p_msg.block
        msg_round = str(block.round)
        # if not check_failure_config(tag, p, to):            # Check if the message is dropped according to the failure config
        #     return
        for validator in list(to):
            if validator in twin_config:                               # Route message based on the twin_config
                twinId = twin_config[validator]
                if not is_message_dropped(msg_round, p, validator):
                    output('Sending Proposal from playground 1', p, validator)
                    send(('proposalMessage', m), to=validator)
                if not is_message_dropped(msg_round, p, twinId):
                    output('Sending Proposal from playground 2', p, twinId)
                    send(('proposalMessage', m), to=twinId)
            elif not is_message_dropped(msg_round, p, validator):
                output('Sending Proposal from playground 3', p, validator)
                send(('proposalMessage', m), to=validator)
            if int(msg_round) > speculative_round:
                speculative_round = int(msg_round)


    '''
    Safety Property 1. If a block is certified in a round, no other block can gather f + 1 non-Byzantine votes in the
    same round. Hence, at most one block is certified in each round.
    To check the above property, we keep a count of votes per block-id, per round. At the end this information, 
    is passed on to the executor, which can then check the safety.
    '''
    def receive(msg=('voteMessageSent', m,), from_= p):
        round_done = True
        (tag, v_msg) = m
        (v_info, _, _, _, _) = v_msg
        msg_round = v_info.round
        process_votes(v_info, sender)
        if not check_failure_config(tag, p, to, round):     # Check if the message is dropped according to the failure config
            return
        if to in twin_config:                               # Route message based on the twin_config
            twinId = twin_config[to]
            if not is_message_dropped(msg_round, p, to):
                send((tag, m), to=to)
            if not is_message_dropped(msg_round, p, twinId):
                send((tag, m), to=twinId)
        if not is_message_dropped(msg_round, p, to):
            send((tag, m), to=to)
        if msg_round > speculative_round:
            speculative_round = msg_round

    def receive(msg=('timeoutMessageSent', m,), from_= p):
        (tag, to_msg) = m
        (to_info, _, _, _, _) = to_msg
        msg_round = to_info.round
        if not check_failure_config(tag, p, to, round):    # Check if the message is dropped according to the failure config
            return
        if not is_message_dropped(msg_round, p, to):
            send((tag, m), to=to)
        if msg_round > speculative_round:
            speculative_round = msg_round

    def receive(msg=('initiateRecoverySent', m,), from_= p):
        (tag, n) = m
        if not is_message_dropped(speculative_round, p, to):
            send((tag, m), to=to)

    def receive(msg=('recoveryMsgSent', m), from_= p):
        (tag, r_msg, _, _) = m
        (_, _, _, pm_state, _) = r_msg
        msg_round = pm_state.pacemaker_current_round
        if not is_message_dropped(msg_round, p, to):
            send((tag, m, x, n), to=to)
        if msg_round > speculative_round:
            speculative_round = msg_round

    def is_message_dropped(round, src, dst):
        if round in drop_config_round:
            if src in drop_config_round[round]:
                if dst in drop_config_round[round][src]:
                    return True
        return False

    def populate_drop_config_round():
        for round_key in round_partitions:
            partition_current = round_partitions[round_key]
            for i, partition in enumerate(partition_current):
                for src in partition:
                    for j in range(i+1, len(round_partitions[round_key])):
                        for dst in round_partitions[round_key][j]:
                            # print(f'round_key {round_key} src {src} dst {dst}')
                            split_network_round(validators[src], validators[dst], round_key)
                            split_network_round(validators[dst], validators[src], round_key)

    def split_network_round(src, dst, round):
        if round not in drop_config_round:
            drop_config_round[round] = {}
        if src not in drop_config_round[round]:
            drop_config_round[round][src] = []
        drop_config_round[round][src].append(dst) # adds {'r1':{'s1': {d1, d2, d3}} ... }

    '''
    Here, 
        map validator to its twin (A -> A')
        assuming, twins are enumerated beginning at the start of the 
        validator list. Eg, if there are two twins in the system,
        we can deduce twins to be, A', & B', ie, signifies the first 
        two nodes as having their twins in the system. This does not 
        hamper the generality of the system, as the scenario partitions
        generated would still be the same. Replacing A with D, and A' with D'
        amounts to have same effect.
    '''
    def populate_twin_config():
        for i in range (0, num_target_nodes):
            twin_config[list(validators)[i]]= list(validators)[num_nodes+i]

    def process_votes(v_info, sender):
        '''
        The structure of the vote_count_config is for every round r, we collect votes
        for each block-id in that round.
        {
            'r1':   {
                        'b_id1': {x1, x2, ...},
                        'b_id2': {y1, y2, ...},
                        ...
                    },
            ...
        }
        '''
        vote_count_config.find_or_create(v_info.round).find_or_create(v_info.id).add_to_set(sender)
